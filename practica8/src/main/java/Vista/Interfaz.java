package Vista;

import java.io.IOException;
import java.util.ArrayList;
import java.util.logging.Level;
import java.util.logging.Logger;
import java.net.InetAddress;
import javax.swing.UnsupportedLookAndFeelException;

import Servidores.ServidorMulticast;
import Servidores.Funciones;
import static Servidores.ServidorMulticast.FIN_ID;
import static Servidores.ServidorMulticast.INICIO_ID;
import Servidores.ServidorRMI;
import Modelo.Mensaje;
import Modelo.Nodo;
import Servidores.MulticastMensajes;
import Servidores.ServidorFlujo;
import java.io.DataInputStream;
import java.io.DataOutputStream;
import java.io.FileOutputStream;
import java.net.DatagramPacket;
import java.net.MulticastSocket;
import java.net.Socket;
import java.net.UnknownHostException;
import java.rmi.registry.LocateRegistry;
import java.rmi.registry.Registry;
import java.util.concurrent.TimeUnit;
import javax.swing.JOptionPane;


public class Interfaz extends javax.swing.JFrame {
    private int puerto;
    private String historial;
    private ArrayList <Nodo> nodos;
    
    private String ip;
    private String nodosDisponibles;
    private String logTemporal;
    
    private boolean primerNodo;
    private boolean ultimoNodo;
    private boolean inicioPeticion;
    
    private Nodo nodo;
    private Nodo nodoSiguiente;
    private Nodo nodoAnterior;

    /*
     * Creates new form Interfaz 
     */
    public Interfaz() throws IOException{
        initComponents();
        init();
    }
    
    /*
     * Configuracion inicial
     */
    private void init() throws IOException{
        //Desactivado el redimensionamiento de la ventana
        this.setResizable(false);
        
        //La ventana se muestra en el centro de la pantalla
        this.setLocationRelativeTo(null);
        
        //El contenido del panel de nodos será en texto y HTML
        nodosConectados.setContentType("text/html");
        //Y es de solo lectura
        nodosConectados.setEditable(false);
        
        //La bitacora es de solo lectura
        Mensajes.setEditable(false);
        
        
        //La cadena auxiliar de la bitácora estará vacía al inicio
        logTemporal = "";
        historial="";
        
        
        //Pedimos a la interfaz del puerto el número de puerto que recibió
        puerto = Integer.parseInt(JOptionPane.showInputDialog(null, "Ingrese el puerto:"));
        historial += "Cliente iniciado en el puerto "+puerto+".\n";
        Mensajes.setText(historial);
                
        //El título de la ventana es el número de puerto
        this.setTitle("" + puerto);
        labelId.setText(""+puerto);
        try{
            ServidorRMI hilormi = new ServidorRMI();
            hilormi.setPto(puerto);
            hilormi.start();
            ServidorFlujo hiloFlujo = new ServidorFlujo();
            hiloFlujo.inicializaServer(puerto+100);
            hiloFlujo.start();
        } catch (Exception e) {
	    e.printStackTrace();
	}
        nodos = new ArrayList<Nodo>();
        
        ip = InetAddress.getLocalHost().getHostAddress();
        
        nodo = new Nodo(ip + ":" + puerto ,ip, puerto);  
        
        //Se invoca al método que anuncia el puerto
        anunciar();
        
        //Se actualiza la lista de nodos
        actualizarListaDeNodosMulticast();
        
        //Se actualizan los eventos
        actualizarMensajes();
    }
    
    

    /** This method is called from within the constructor to
     * initialize the form.
     * WARNING: Do NOT modify this code. The content of this method is
     * always regenerated by the Form Editor.
     */
    @SuppressWarnings("unchecked")
    // <editor-fold defaultstate="collapsed" desc="Generated Code">//GEN-BEGIN:initComponents
    private void initComponents() {

        lblSiguienteEstatico = new javax.swing.JLabel();
        lblSiguienteDinamico = new javax.swing.JLabel();
        lblAnteriorEstatico = new javax.swing.JLabel();
        lblAnteriorDinamico = new javax.swing.JLabel();
        txtBuscar = new javax.swing.JTextField();
        btnBuscar = new javax.swing.JButton();
        jScrollPane3 = new javax.swing.JScrollPane();
        nodosConectados = new javax.swing.JEditorPane();
        jScrollPane1 = new javax.swing.JScrollPane();
        Mensajes = new javax.swing.JEditorPane();
        jLabel1 = new javax.swing.JLabel();
        jLabel2 = new javax.swing.JLabel();
        jLabel3 = new javax.swing.JLabel();
        jLabel4 = new javax.swing.JLabel();
        labelId = new javax.swing.JLabel();

        setDefaultCloseOperation(javax.swing.WindowConstants.EXIT_ON_CLOSE);

        lblSiguienteEstatico.setFont(new java.awt.Font("Arial", 0, 14)); // NOI18N
        lblSiguienteEstatico.setHorizontalAlignment(javax.swing.SwingConstants.CENTER);
        lblSiguienteEstatico.setText("Sucesor:");

        lblSiguienteDinamico.setFont(new java.awt.Font("Arial", 0, 14)); // NOI18N

        lblAnteriorEstatico.setFont(new java.awt.Font("Arial", 0, 14)); // NOI18N
        lblAnteriorEstatico.setHorizontalAlignment(javax.swing.SwingConstants.CENTER);
        lblAnteriorEstatico.setText("Antecesor:");

        lblAnteriorDinamico.setFont(new java.awt.Font("Arial", 0, 14)); // NOI18N

        txtBuscar.setText(" ");

        btnBuscar.setText("Buscar");
        btnBuscar.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                btnBuscarActionPerformed(evt);
            }
        });

        jScrollPane3.setBorder(null);

        nodosConectados.setBorder(null);
        jScrollPane3.setViewportView(nodosConectados);

        jScrollPane1.setBorder(null);
        jScrollPane1.setHorizontalScrollBarPolicy(javax.swing.ScrollPaneConstants.HORIZONTAL_SCROLLBAR_NEVER);

        Mensajes.setBorder(null);
        jScrollPane1.setViewportView(Mensajes);

        jLabel1.setFont(new java.awt.Font("Arial", 0, 14)); // NOI18N
        jLabel1.setText("Identificador:");

        jLabel2.setFont(new java.awt.Font("Arial", 0, 14)); // NOI18N

        jLabel3.setFont(new java.awt.Font("Arial", 0, 14)); // NOI18N
        jLabel3.setText("Nombre del archivo: ");

        jLabel4.setFont(new java.awt.Font("Arial", 0, 14)); // NOI18N
        jLabel4.setText("Disponibles: ");

        labelId.setFont(new java.awt.Font("Arial", 0, 14)); // NOI18N

        javax.swing.GroupLayout layout = new javax.swing.GroupLayout(getContentPane());
        getContentPane().setLayout(layout);
        layout.setHorizontalGroup(
            layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
            .addGroup(layout.createSequentialGroup()
                .addGroup(layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
                    .addGroup(layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
                        .addGroup(layout.createSequentialGroup()
                            .addContainerGap()
                            .addComponent(jScrollPane1)
                            .addGap(55, 55, 55))
                        .addGroup(layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
                            .addGroup(layout.createSequentialGroup()
                                .addGap(36, 36, 36)
                                .addComponent(jLabel3)
                                .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED)
                                .addComponent(txtBuscar, javax.swing.GroupLayout.PREFERRED_SIZE, 213, javax.swing.GroupLayout.PREFERRED_SIZE)
                                .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.UNRELATED)
                                .addComponent(btnBuscar))
                            .addGroup(javax.swing.GroupLayout.Alignment.TRAILING, layout.createSequentialGroup()
                                .addGap(26, 26, 26)
                                .addGroup(layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
                                    .addGroup(layout.createSequentialGroup()
                                        .addGap(297, 297, 297)
                                        .addComponent(jLabel2, javax.swing.GroupLayout.PREFERRED_SIZE, 203, javax.swing.GroupLayout.PREFERRED_SIZE))
                                    .addGroup(layout.createSequentialGroup()
                                        .addGap(28, 28, 28)
                                        .addComponent(lblSiguienteEstatico, javax.swing.GroupLayout.PREFERRED_SIZE, 68, javax.swing.GroupLayout.PREFERRED_SIZE)
                                        .addGap(31, 31, 31)
                                        .addComponent(lblSiguienteDinamico, javax.swing.GroupLayout.PREFERRED_SIZE, 213, javax.swing.GroupLayout.PREFERRED_SIZE))
                                    .addGroup(layout.createParallelGroup(javax.swing.GroupLayout.Alignment.TRAILING)
                                        .addComponent(labelId, javax.swing.GroupLayout.PREFERRED_SIZE, 220, javax.swing.GroupLayout.PREFERRED_SIZE)
                                        .addGroup(layout.createSequentialGroup()
                                            .addComponent(lblAnteriorEstatico, javax.swing.GroupLayout.PREFERRED_SIZE, 131, javax.swing.GroupLayout.PREFERRED_SIZE)
                                            .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED)
                                            .addComponent(lblAnteriorDinamico, javax.swing.GroupLayout.PREFERRED_SIZE, 213, javax.swing.GroupLayout.PREFERRED_SIZE)))))))
                    .addGroup(layout.createSequentialGroup()
                        .addGap(43, 43, 43)
                        .addComponent(jLabel1)
                        .addGap(402, 402, 402)))
                .addGroup(layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
                    .addComponent(jScrollPane3, javax.swing.GroupLayout.PREFERRED_SIZE, 170, javax.swing.GroupLayout.PREFERRED_SIZE)
                    .addComponent(jLabel4))
                .addGap(22, 22, 22))
        );
        layout.setVerticalGroup(
            layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
            .addGroup(layout.createSequentialGroup()
                .addGroup(layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
                    .addGroup(layout.createSequentialGroup()
                        .addGap(20, 20, 20)
                        .addComponent(jLabel2)
                        .addGap(5, 5, 5)
                        .addGroup(layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
                            .addComponent(labelId, javax.swing.GroupLayout.PREFERRED_SIZE, 17, javax.swing.GroupLayout.PREFERRED_SIZE)
                            .addComponent(jLabel1))
                        .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED)
                        .addGroup(layout.createParallelGroup(javax.swing.GroupLayout.Alignment.TRAILING)
                            .addComponent(lblAnteriorEstatico, javax.swing.GroupLayout.PREFERRED_SIZE, 24, javax.swing.GroupLayout.PREFERRED_SIZE)
                            .addComponent(lblAnteriorDinamico, javax.swing.GroupLayout.PREFERRED_SIZE, 24, javax.swing.GroupLayout.PREFERRED_SIZE))
                        .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.UNRELATED)
                        .addGroup(layout.createParallelGroup(javax.swing.GroupLayout.Alignment.TRAILING)
                            .addComponent(lblSiguienteEstatico, javax.swing.GroupLayout.PREFERRED_SIZE, 24, javax.swing.GroupLayout.PREFERRED_SIZE)
                            .addComponent(lblSiguienteDinamico, javax.swing.GroupLayout.PREFERRED_SIZE, 24, javax.swing.GroupLayout.PREFERRED_SIZE))
                        .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED)
                        .addGroup(layout.createParallelGroup(javax.swing.GroupLayout.Alignment.BASELINE)
                            .addComponent(txtBuscar, javax.swing.GroupLayout.PREFERRED_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.PREFERRED_SIZE)
                            .addComponent(jLabel3)
                            .addComponent(btnBuscar))
                        .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED)
                        .addComponent(jScrollPane1, javax.swing.GroupLayout.PREFERRED_SIZE, 215, javax.swing.GroupLayout.PREFERRED_SIZE))
                    .addGroup(layout.createSequentialGroup()
                        .addContainerGap()
                        .addComponent(jLabel4)
                        .addGap(18, 18, 18)
                        .addComponent(jScrollPane3, javax.swing.GroupLayout.PREFERRED_SIZE, 282, javax.swing.GroupLayout.PREFERRED_SIZE)))
                .addGap(0, 29, Short.MAX_VALUE))
        );

        pack();
    }// </editor-fold>//GEN-END:initComponents

    private void btnBuscarActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_btnBuscarActionPerformed
        // TODO add your handling code here:
        try {
	    Registry registry = LocateRegistry.getRegistry(nodoSiguiente.getIp(), nodoSiguiente.getPuerto());	
            //también puedes usar getRegistry(String host, int port)
	    Funciones stub = (Funciones) registry.lookup("Funciones");
            MulticastMensajes mess = new MulticastMensajes ();
            String nombre = txtBuscar.getText().replaceAll(" ", "");
            String host="";
	    int response = stub.buscarArchivo(nombre, puerto, nodos);//Nombre del archivo a buscar
	    if (response == -1){
                mess.enviaMensaje("<"+puerto+">"+"Archivo "+nombre+" no localizado.\n");
            }else{
                for (int i = 0; i < nodos.size(); i++){
                    if (nodos.get(i).getPuerto()==response){
                        host=nodos.get(i).getIp();
                        break;
                    }
                }
                Socket cl = new Socket(host, response+100);
                
                DataOutputStream dos = new DataOutputStream(cl.getOutputStream());
                DataInputStream dis = new DataInputStream(cl.getInputStream());
                dos.writeUTF(nombre);
                dos.flush();
                long tam = dis.readLong ();
                int numByte = 1024, n;
                DataOutputStream dosRecv = new DataOutputStream(new FileOutputStream("Carpetas"+puerto+"/"+nombre));
                int recibidos = 0, porcentaje, aux=10;
                int bitRes = numByte;
                byte[] b = new byte[numByte];
                while(recibidos < tam){
                    if ((tam-recibidos) < numByte){
                        bitRes = (int)(tam-recibidos);
                    }
                    n = dis.read(b, 0, bitRes);
                    dosRecv.write(b,0,n);
                    dosRecv.flush();
                    recibidos = recibidos + n;
                    porcentaje = (int)(recibidos*100/tam);
                    if (porcentaje >= aux){
                        mess.enviaMensaje("<"+puerto+">"+nombre+": porcentaje recibido de "+porcentaje+"%\n");
                        aux += 10;
                    }
                }//while
                dosRecv.close();
                dos.close();
                dis.close();
                cl.close();
            }
	} catch (Exception e) {
	    System.err.println("Excepción del cliente: " + e.toString());
	    e.printStackTrace();
	}
    }//GEN-LAST:event_btnBuscarActionPerformed

    /**
     * @param args the command line arguments
     */
    public static void main(String args[]) throws UnsupportedLookAndFeelException {
        //</editor-fold>

        /* Create and display the form */
        java.awt.EventQueue.invokeLater(new Runnable() {
            public void run() {
                try {
                    new Interfaz().setVisible(true);
                } catch (IOException ex) {
                    Logger.getLogger(Interfaz.class.getName()).log(Level.SEVERE, null, ex);
                }
            }
        });
    }
    
    /*
    * Metodo que recibe un mensaje y con base en el actualiza 
    * la lista de nodos en la interfaz
    */
    private void actualizarMulticast() throws IOException{
        Mensaje mensaje = ServidorMulticast.getInstance().recibe();
        
        if(mensaje.getNombreOrigen() != null){
            switch (mensaje.getId()) {
                case INICIO_ID:
                    if (!mensaje.getNombreOrigen().equals(nodo.getId())) {
                        if(anadirNodo(mensaje.getNombreOrigen())){
                            actualizarListaDeNodos();
                            nodoSiguiente = getNodoSiguiente(puerto);
                            nodoAnterior = getNodoAnterior(puerto);
                            lblAnteriorDinamico.setText(""+nodoAnterior.getPuerto());
                            lblSiguienteDinamico.setText(""+nodoSiguiente.getPuerto());
                        }
                    }
                break;
                case FIN_ID:
                    if(removerNodo(mensaje.getNombreOrigen())){
                        actualizarListaDeNodos(); 
                        
                        if(nodos.size() > 0){
                            nodoSiguiente = getNodoSiguiente(puerto);
                            nodoAnterior = getNodoAnterior(puerto);
                            lblAnteriorDinamico.setText(""+nodoAnterior.getPuerto());
                            lblSiguienteDinamico.setText(""+nodoSiguiente.getPuerto());
                        }else{
                            lblAnteriorDinamico.setText("");
                            lblSiguienteDinamico.setText("");
                        }
                    }
                break;
                default:
            }
        }
    }
    
    /*
     * Método que obtiene el puerto de un nodo
     * @param idNodo nodo al que se quiere saber su puerto
     */
    private int getPuerto(String idNodo){
        String puerto = "";
        char c;
        int i = 0;
        
        while((c = idNodo.charAt(i)) != ':'){
            i++;
        }
        
        puerto = idNodo.substring(i + 1);
        
        return Integer.parseInt(puerto);
    }
    
    /*
     * Método que obtiene la IP de un nodo
     * @param idNodo nodo al que se quiere saber su IP
     */
    private String getIP(String idNodo){
        String ip = "";
        char c;
        int i = 0;
        
        while((c = idNodo.charAt(i)) != ':'){
            ip += c;
            i++;
        }
        
        return ip;
    }

    /*
     * Método que determina si se trata del nodo mayor
     * @param idNodo nodo a comparar
     */
    private boolean esNodoMayor(int idNodo){
        int tamano = nodos.size();
        Nodo n;
        
        for(int i = 0; i < tamano ; i++){
            n = (Nodo) nodos.get(i);
            
            if(n.getPuerto() > idNodo){
                return false;
            }
        }
        
        return true;   
    }
    
    /*
     * Método que determina si se trata del nodo menor
     * @param idNodo nodo a comparar
     */
    private boolean esNodoMenor(int idNodo){
        int tamano = nodos.size();
        Nodo n;
        
        for(int i = 0; i < tamano ; i++){
            n = (Nodo) nodos.get(i);
            
            if(idNodo > n.getPuerto()){
                return false;
            }
        }
        
        return true;
    }
    
    /*
     * Método que devuelve el nodo con menor número de puerto
     */
    private Nodo getNodoMenor(){
        int tamano = nodos.size();
        Nodo n = (Nodo)nodos.get(0);
        int menor = n.getPuerto();
        int j = 0;
        
        for (int i = 1; i < tamano; i++) {
            n = (Nodo)nodos.get(i);
            
            if (n.getPuerto() < menor) {
                menor = n.getPuerto();
                j = i;
            }
        }
        
        return (Nodo)nodos.get(j);
    }
    
    /*
     * Método que devuelve el nodo con mayor número de puerto
     */
    private Nodo getNodoMayor(){
        int tamano = nodos.size();
        Nodo n = (Nodo)nodos.get(0);
        int mayor = n.getPuerto();
        int j = 0;
        
        for (int i = 1; i < tamano; i++) {
            n = (Nodo)nodos.get(i);
            
            if (n.getPuerto() > mayor) {
                mayor = n.getPuerto();
                j = i;
            }
        }
        
        return (Nodo)nodos.get(j);
    }
    
    /*
     * Método que actualiza la lista de nodos y los muestra en el cuadro de texto txtNodosConectados
     */
    private void actualizarListaDeNodos(){
        nodosDisponibles = "";
        int tam = nodos.size();
        Nodo n;
        
        for(int i = 0; i < tam ; i++){
            n = (Nodo) nodos.get(i);
            
            nodosDisponibles += ("<br>" + n.getId());  
        }
        
        nodosConectados.setText(nodosDisponibles);
    }
    
    /*
     * Método que devuelve el nodo anterior en la topología
     * @param idNodoPuerto nodo al que se quiere saber su anterior nodo
     */
    private Nodo getNodoAnterior(int idNodoPuerto){
        Nodo n = null;
        
        if(esNodoMenor(idNodoPuerto)){
            n = getNodoMayor();
        }else{           
            int tam = nodos.size();
            int resta = 2147483647;
            int aux, j = 0;
            
            for (int i = 0; i < tam; i++) {
                n = (Nodo)nodos.get(i);
                aux =  idNodoPuerto - n.getPuerto();
                
                if (aux < resta && aux > 0) {
                    resta = aux;
                    j = i;
                }
            }
            
            n = (Nodo)nodos.get(j);
        }
        
        return n;      
    }
    
    /*
     * Método que devuelve el nodo siguiente en la topología
     * @param idNodoPuerto nodo al que se quiere obtener su siguiente nodo
     */
    private Nodo getNodoSiguiente(int idNodoPuerto){
        Nodo n = null;
        
        if(esNodoMayor(idNodoPuerto)){
            n = getNodoMenor();
        }else{
            int tam = nodos.size();
            int resta = 2147483647;
            int aux, j = 0;
            
            for (int i = 0; i < tam; i++) {
                n = (Nodo)nodos.get(i);
                aux = n.getPuerto() - idNodoPuerto;
                
                if (aux < resta && aux > 0) {
                    resta = aux;
                    j = i;
                }
            }
            
            n = (Nodo)nodos.get(j);
        }
        
        return n;
    }
    
    /*
     * Método que añade un nodo a la lista de nodos (ArrayList)
     * @param id nodo a añadir
     */
    private boolean anadirNodo(String id){
        int tam = nodos.size();
        Nodo n;
        
        for(int i = 0; i < tam ; i++){
            n = (Nodo)nodos.get(i);
            
            if(n.getId().equals(id)){
                return false;
            }
        }
        
        nodos.add(new Nodo(id, getIP(id), getPuerto(id)));
        
        return true;
    }
    
    /*
     * Método que remueve un nodo de la lista de nodos (ArrayList)
     * @param id nodo a remover
     */
    private boolean removerNodo(String id){
        int tam = nodos.size();
        Nodo n;
        
        for(int i = 0; i < tam ; i++){
            n = (Nodo)nodos.get(i);
            
            if(n.getId().equals(id)){
                nodos.remove(i);
                
                return true;
            }
        }
        
        return false;       
    }
    
    /* 
     * Función para ver detalles de un nodo (ID, IP, Puerto) [Debuggeo]
     * @param n Nodo al que se quiere saber sus detalles
     */
    private void imprimirNodo(Nodo n){
        System.out.print("Id: " + n.getId() +"\n");
        System.out.print("IP: " + n.getIp() +"\n");
        System.out.print("Puerto: " + n.getPuerto() + "\n");
    }
    
    public void mensaje(String message) {
        logTemporal += (message + "<br>");
        Mensajes.setText(logTemporal);
    }
    /*
     * Hilo para anunciar el puerto de servicio este anuncio se realiza cada 5 segundos.
     */
    private void anunciar(){
        Thread hilo = new Thread(){
            public void run(){
                while(true){
                    try {
                        ServidorMulticast.getInstance().anunciar(nodo.getId());
                        TimeUnit.SECONDS.sleep(5);
                    } catch (IOException ex) {
                        Logger.getLogger(Interfaz.class.getName()).log(Level.SEVERE, null, ex);
                    } catch (InterruptedException ex) {
                        Logger.getLogger(Interfaz.class.getName()).log(Level.SEVERE, null, ex);
                    }
                }
            }
        };

        hilo.start();
    }
    
    
    /*
     * Hilo para actualizar la lista de nodos
     */
    private void actualizarListaDeNodosMulticast(){
        Thread hilo = new Thread() {
            public void run(){
                while(true){
                    try {
                       actualizarMulticast();
                    } catch (IOException ex){
                        Logger.getLogger(Interfaz.class.getName()).log(Level.SEVERE, null, ex);
                    }
                }
            }
        };

        hilo.start();
    }

    public void actualizarMensajes(){
        Thread hiloMensajes = new Thread(){
            public void run(){
                InetAddress gpo = null;
            try {
                MulticastSocket cl = new MulticastSocket (9999);
                System.out.println("Cliente escuchando puerto: "+cl.getLocalPort ());
                cl.setReuseAddress(true);
                try {
                    gpo = InetAddress.getByName ("228.1.1.1");

                } catch (UnknownHostException e) {
                    System.err.println ("Dirrección no valida");
                }//Catch
                cl.joinGroup(gpo);
                System.out.println("Unido al grupo");
                for (;;){
                    DatagramPacket p = new DatagramPacket(new byte [100], 100);
                    cl.receive(p);
                    String msj = new String (p.getData ());
                    if (msj.contains("<"+puerto+">")){
                        historial+=msj.replace("<"+puerto+">", "");
                        Mensajes.setText(historial);
                    }
                }
            } catch (Exception e) {
                e.printStackTrace();
            }
            }
        };

        hiloMensajes.start();
    }
    
    // Variables declaration - do not modify//GEN-BEGIN:variables
    private javax.swing.JEditorPane Mensajes;
    private javax.swing.JButton btnBuscar;
    private javax.swing.JLabel jLabel1;
    private javax.swing.JLabel jLabel2;
    private javax.swing.JLabel jLabel3;
    private javax.swing.JLabel jLabel4;
    private javax.swing.JScrollPane jScrollPane1;
    private javax.swing.JScrollPane jScrollPane3;
    private javax.swing.JLabel labelId;
    private javax.swing.JLabel lblAnteriorDinamico;
    private javax.swing.JLabel lblAnteriorEstatico;
    private javax.swing.JLabel lblSiguienteDinamico;
    private javax.swing.JLabel lblSiguienteEstatico;
    private javax.swing.JEditorPane nodosConectados;
    private javax.swing.JTextField txtBuscar;
    // End of variables declaration//GEN-END:variables

}
